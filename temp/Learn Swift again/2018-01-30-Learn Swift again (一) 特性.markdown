---
layout: post
title:  "Learn Swift again (一) 特性"
date:   2018-01-30 15:29:31 +0800
categories: Learn Swift again
---
![](http://yuqiangcoder.com/assets/postImages/ios/201801/1.png)

### 前言
学习 `Swift` 有一段时间了, 期间使用 `Swift` 写过一些控件([YQAlert](https://github.com/YQqiang/YQAlert), [UIViewControllerYQAlert](https://github.com/YQqiang/UIViewControllerYQAlert)),功能单一的APP([Nunchakus](https://github.com/YQqiang/Nunchakus)), 及简单的MAC工具([LocalizationTool](https://github.com/YQqiang/LocalizationTool), [InsertCodeTool](https://github.com/YQqiang/InsertCodeTool)), 也在工作项目使用`Swift`开发过部分功能, 但对`Swift`语言特性的理解仍然停留在表面, 写不出符合Swift编码习惯的代码.
为了进一步学习`Swift`, 以便在开发中能够灵活运用, 因此决定重新学习`Swift`.
之前的学习都是通过[Swift 中文文档](http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html) 及大牛们打技术博客. 这次学习`Swift`, 我选择了喵大的译作[Swift 进阶](https://objccn.io/products/advanced-swift/), 不出意外的话, 博客大部分内容都会摘自该书🤣. 此处整理, 仅供自己翻阅😂.

### Swift 概述
> Swift 可以像 C 一样进行低层级的位操作, 但又可以避免许多未定义行为的陷阱. Ruby的教徒可以在像是map 或 filter 的轻量级的尾随闭包中感受到宾至如归. Swift 的泛型和 C++ 的模板如出一辙, 但是额外的类型约束能保证泛型方法在被定义时就是正确的, 而不必等到使用的时候再进行判定. 灵活的高阶函数和运算符重载能够以 Haskell 或 F# 那样的风格进行编码. 最后 @objc 和 dynamic 关键字允许你像在 Objective-C 中那样使用 selector 和各种运行时的动态特性.

### Swift 主题
* Swift 既是一门高层级语言, 又是一门低层级语言.
* Swift 是一门多范式的语言.
* Swift 十分灵活.
* Swift 代码可以做到紧凑, 精确, 同时保持清晰.
* 除非你有意为之, 否则 Swift 在实践中总是安全的.
* Swift 是一门独断的语言.
* Swift 在持续进化中.

### Swift 术语
> 你用, 或是不用, 术语就在那里, 不多不少. 你懂, 或是不懂, 定义就在那里, 不偏不倚.

##### 值 && 引用
* **值(value)** 时不变的, 永久的, 它从不会改变.
* `var x = [1, 2]`, 创建一个x 的**变量(variable)**来持有[1, 2]这个值.
* 还可以使用 `let` 而不是 `var` 来声明一个**常量变量(constant variables)**, 或者简称常量.
* 结构体(struct) 和 枚举(enum) 是 **值类型(value type)**
* **引用(reference)**是一种特殊类型的值: 它是一个"指向"另一个值得值.
* 类(class)时**引用类型(reference type)**. 你不能在一个变量里直接持有一个类的实例(我们偶尔可能会把这个实例称作**对象(Object)**). 对于一个类的实例, 我们只能在变量里持有对它的引用, 然后使用这个引用来访问它.
* 引用类型具有**同一性(identity)**, 也就是说, 你可以使用`===`来检查两个变量是否确实引用了同一个对象.
* 值类型不存在同一性的问题.
* 在程序语言的论文里, `==` 有时候被称为**结构相等**, 而 `===`则被称为**指针相等**或者**引用相等**.
* Swift中, 类引用不是唯一的引用类型. Swift中依然有指针, 比如使用`withUnsafeMutablePointer` 和类似方法所得到的就是指针.
* 一个引用变量也可以使用`let`来声明, 这样做会使引用变为常量. 这并不意味着这个变量所引用的对象本身不能被改变. 所以, 当用常量的方式来引用变量的时候要格外小心, 只有指向关系被常量化了, 而对象本身还是可变的.
* 我们通过值类型是否执行**深复制**来对他们分类, 判断他们是否具有**值语义(value semantic)**. 这种复制可能是在赋值新变量时就发生的, 也可能会延迟到变量内容发生变更的时候再发生.
* 如果我们结构体中含有引用类型, 在将结构体赋值给一个新变量是所发生的赋值行为中, 这些引用类型的内容是不会被自动赋值一份的, 只有引用本身会被复制. 这种复制的行为被称作**浅复制(shallow copy)**.
* 例: `Foundation`框架中的`Data`结构体实际上是对引用类型`NSData`的一个封装. 不过, `Data`的作者采取了额外的步骤, 来保证当`Data`结构体发生变化的时候对其中的`NSData`对象进行深复制. 他们使用一种名为**写时复制(copy-on-write)**的技术来保证操作的高效.
* 有些类是完全不可变的, 也就是说, 从被创建以后, 他们就不提供任何方法来改变他们的内部状态. 这意味着即使它们是类, 它们依然具有值语义(因为它们就算被到处使用也从不会改变). 只有那些标记为`final`的类能够保证不被子类化, 也不会被添加可变状态.

##### 函数
* 在Swift中, 函数也是值. 你可以讲一个函数赋值给一个变量, 也可以创建一个包含函数的数组, 或者调用变量所持有的函数.
* 如果一个函数接受别的函数作为参数, 或者一个函数的返回值是函数, 那么这样的函数就叫做**高阶函数(higher-order function)**
* 函数不需要被声明在最高层级---你可以在一个函数内部声明另一个函数, 也可以在一个do作用域或者其他作用域中声明函数. 如果一个函数被定义在外层作用域中, 但是被传递出这个作用域(比如吧这个函数作为其他函数的返回值时), 它降能够"捕获"局部变量. 这些局部变量将存在于函数中, 不会随着局部作用域的结束而消亡, 函数也将持有它们的状态. 这种行为的变量被称为"闭合变量", 我们把这样的函数叫做**闭包(closure)**.
* 函数可以通过 `func` 关键字来定义, 也可以通过 `{}` 这样的简短的**闭包表达式(closure expression)**来定义. 有时候我们只把通过闭包表达式创建的函数叫做"闭包", 不过不要让这种叫法蒙蔽了你的双眼.实际上用 `func` 关键字定义的函数, 如果它包含了外部的变量, 那么它也是一个闭包.
* 函数是引用类型. 也就是说, 将一个捕获了状态的函数赋值给另一个变量, 并不会导致这些状态被赋值. 和对象引用类似, 这些状态会被共享. 换句话说, 当两个闭包持有同样的局部变量是, 他们是共享这个变量的以及它的状态的.
* 定义在类或者协议中的函数就是**方法(method)**, 它们有一个隐式`self`参数.
* 如果一个函数不是接受多个参数, 而是只接受部分参数, 然后返回一个接受其余参数的函数的话, 那么这个函数就是一个**柯里化函数(curried function).
* 有时候我们会把那些不是方法的函数叫做**自由函数**.

##### 静态派发 && 动态派发
* 自由函数和那些在结构体上调用的方法是**静态派发(statically dispatched)**的. 对于这些函数的调用, 在编译的时候就已经确定了.
* 对于静态派发的调用, 编译器可能能够**内联(inline)**这些函数, 也就是说, 完全不去做函数调用, 而是将函数调用替换为函数中需要执行的代码. 优化器还能够帮助丢弃或简化那些在编译时就能确定不会被实际执行的代码.
* 类或者协议上的方法可能是**动态派发(dynamically dispatched)的. 编译器在编译时不需要知道哪个函数将被调用. 在Swift中, 这种动态特性要么有`vtable`来完成, 要么通过`selector`和`objc_msgSend`来完成.

##### 重写 && 重载
* 子类型和方法**重写(overriding)**是实现**多态(polymorphic)**特性的手段, 也就是说, 根据类型的不同, 同样的方法会呈现出不同的行为.
* 另一种方式是函数**重载(overloading)**, 它是指为不同的类型多次写同一个函数的行为.
* 实现多态的第三种方法是通过泛型, 也就是一次性地编写能够接受任意类型的函数或者方法, 不过这些方法的实现会各有不同. 与方法重写不同的时, 泛型中的方法在编译期间就是静态已知的.

### Swift 风格
* 使用类型推断. 省略掉显而易见的类型会有助于提高可读性.
* 如果存在歧义或者在进行定义的时候不要使用类型推断.(比如 `func` 就需要显示地指定返回类型)
* 优先选择结构体, 只在确实需要使用到类特有的特性或者是引用语义时才使用类.
* 除非你的设计就是希望某个类被继承使用, 否则都应该将他们标记为`final`.
* 除非一个闭包后面立即跟随有左括号, 否则都应该使用尾随闭包(trailing closure)的语法.
* 使用`guard`来提早退出某个方法.
* 不要写重复的代码. 如果你发现你写了好几次类似的代码片段的话, 试着将它们提取到一个函数里, 并且考虑将这个函数转化为协议扩展的可能性.
* 试着去使用不可变值: 除非你需要改变某个值, 否则都应该使用`let`来声明变量. 不过如果能让代码更加清晰高效的话, 也可以选择使用可变的版本. 用函数将可变的不部分封装起来, 可以把它带来的副作用进行隔离.
* 除非你确实需要, 否则不需要使用`self.`.不过在闭包表达式中, `self`是被强制使用的, 这是一个清晰的信号, 表明闭包将会捕获`self`.
* 尽可能地对现有的类型和协议进行扩展, 而不是写一些全局函数. 这有助于提高可读性, 让别人更容易发现你的代码.

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/

