<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="baidu-site-verification" content="w9Akh6dPe4" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
<!--[if lte IE 8]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

<title>RxSwift 成长之路---基本概念和语法 | 逆行云的技术博客</title>
<meta name="author" content="逆行云">




<link rel="shortcut icon" href="" />

<link rel="stylesheet" type="text/css" href="/assets/css/style.css">

<link href="/pages/rss.xml" rel="alternate" title="逆行云的技术博客" type="application/atom+xml">



  </head>
  <body>
        <aside id="sidebar">
  <nav id="tags">
    <a href="/index.html" id="avatar" style="background-image:url(https://github.com/YQqiang/YQqiang.github.io/blob/master/assets/images/mine.JPG?raw=true)"></a>

    <ul id="tags__ul">
      <li id="pl__all" class="tags__li tags-btn active">所有文章</li>
       
        <li id="开发笔记" class="tags__li tags-btn">开发笔记</li>
       
        <li id="函数式Swift" class="tags__li tags-btn">函数式Swift</li>
       
        <li id="项目维护" class="tags__li tags-btn">项目维护</li>
       
        <li id="开源项目" class="tags__li tags-btn">开源项目</li>
      
    </ul>

    <div id="tags__bottom">
      <a href="https://github.com/YQqiang" id="icon-github" class="tags-btn fontello" target="_blank"></a>
      <a href="/pages/rss.xml" id="icon-feed" class="tags-btn fontello" target="_blank"></a>
      <a href="mailto:yuqiang.coder@gmail.com" id="icon-email" class="tags-btn fontello"></a>
    </div>
  </nav> <!-- end #tags -->

  <div id="posts-list">
    <form action="" id="search-form">
      <a href="/index.html" id="mobile-avatar" style="background-image:url(https://github.com/YQqiang/YQqiang.github.io/blob/master/assets/images/mine.JPG?raw=true)"></a>
      <!-- NOTE: input field is disabled by default -->
      <input id="search-input" type="text" placeholder="Search..." >
    </form>

    <nav id="pl__container">
    
      <a class="开发笔记 pl__all" href="/2017/08/30/@strongify(self)-%E5%92%8C-@weakify(self)-%E5%AE%8F.html"><span class="pl__circle"></span><span class="pl__title">@strongify(self) 和 @weakify(self) 宏</span><span class="pl__date">17/08/30</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/08/17/UserInfo=-NSDebugDescription=Garbage-at-end.-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><span class="pl__circle"></span><span class="pl__title">UserInfo={NSDebugDescription=Garbage at end.}解决方案</span><span class="pl__date">17/08/17</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/07/29/%E4%BD%BF%E7%94%A8RunTime%E6%B8%85%E7%A9%BA%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%80%BC.html"><span class="pl__circle"></span><span class="pl__title">使用RunTime清空单例对象属性值</span><span class="pl__date">17/07/29</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/07/12/UIBezierPath-+-CAShapeLayer-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">UIBezierPath + CAShapeLayer 实战应用</span><span class="pl__date">17/07/12</span></a>
    
      <a class="项目维护 pl__all" href="/2017/06/20/%E9%A1%B9%E7%9B%AE%E7%BB%B4%E6%8A%A4-%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E6%8E%A7%E4%BB%B6%E5%B0%81%E8%A3%85.html"><span class="pl__circle"></span><span class="pl__title">项目维护<<模糊搜索控件封装>></span><span class="pl__date">17/06/20</span></a>
    
      <a class="项目维护 pl__all" href="/2017/06/13/%E9%A1%B9%E7%9B%AE%E7%BB%B4%E6%8A%A4-%E5%9C%B0%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">项目维护<<地图相关总结>></span><span class="pl__date">17/06/13</span></a>
    
      <a class="项目维护 pl__all" href="/2017/06/03/%E9%A1%B9%E7%9B%AE%E7%BB%B4%E6%8A%A4-%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%A0%87%E9%A2%98%E6%8D%A2%E8%A1%8C%E6%98%BE%E7%A4%BA.html"><span class="pl__circle"></span><span class="pl__title">项目维护<<导航栏标题换行显示>></span><span class="pl__date">17/06/03</span></a>
    
      <a class="开源项目 pl__all" href="/2017/04/28/iOS-YQAlert-%E5%BC%B9%E5%87%BA%E6%A1%86-%E4%B8%AA%E4%BA%BA%E5%BA%93.html"><span class="pl__circle"></span><span class="pl__title">iOS YQAlert 弹出框 -- 个人库</span><span class="pl__date">17/04/28</span></a>
    
      <a class="开源项目 pl__all" href="/2017/04/19/Nunchakus-%E4%B8%AA%E4%BA%BAAPP.html"><span class="pl__circle"></span><span class="pl__title">Nunchakus -- 个人APP</span><span class="pl__date">17/04/19</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/04/07/git-%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">git 日常使用小结</span><span class="pl__date">17/04/07</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/03/20/BgImgTextView.html"><span class="pl__circle"></span><span class="pl__title">BgImgTextView</span><span class="pl__date">17/03/20</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/03/07/Swift-%E6%8A%80%E8%83%BD%E5%B0%8F%E7%BB%93(%E4%BA%8C).html"><span class="pl__circle"></span><span class="pl__title">Swift-技能小结(二)</span><span class="pl__date">17/03/07</span></a>
    
      <a class="项目维护 pl__all" href="/2017/02/25/%E4%BD%BF%E7%94%A8NSUserDefaults%E6%8C%81%E4%B9%85%E5%8C%96%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">使用NSUserDefaults持久化登录接口数据的填坑笔记</span><span class="pl__date">17/02/25</span></a>
    
      <a class="函数式Swift pl__all" href="/2017/02/23/RxSwift-+-Moya-+-ObjectMapper-+-MVVM-%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82.html"><span class="pl__circle"></span><span class="pl__title">RxSwift + Moya + ObjectMapper + MVVM 的网络请求</span><span class="pl__date">17/02/23</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/02/22/Swift-%E6%8A%80%E8%83%BD%E5%B0%8F%E7%BB%93(%E4%B8%80).html"><span class="pl__circle"></span><span class="pl__title">Swift-技能小结(一)</span><span class="pl__date">17/02/22</span></a>
    
      <a class="函数式Swift pl__all" href="/2017/02/14/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-swift%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D(%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0Map%E5%87%BD%E6%95%B0).html"><span class="pl__circle"></span><span class="pl__title">高阶函数---swift中的泛型介绍(一步步实现Map函数)</span><span class="pl__date">17/02/14</span></a>
    
      <a class="函数式Swift pl__all" href="/2017/02/14/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-swift%E4%B8%AD%E7%9A%84Filter-%E5%92%8C-Reduce.html"><span class="pl__circle"></span><span class="pl__title">高阶函数---swift中的Filter 和 Reduce</span><span class="pl__date">17/02/14</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/02/13/iOS-%E5%BD%93%E7%BC%96%E8%BE%91%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E6%97%B6,-%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%B8%85%E7%A9%BA%E6%96%87%E6%9C%AC%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><span class="pl__circle"></span><span class="pl__title">iOS---当编辑密码输入框时, 会自动清空文本框问题解决方案</span><span class="pl__date">17/02/13</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/02/09/REMOTE-HOST-IDENTIFICATION-HAS-CHANGED.html"><span class="pl__circle"></span><span class="pl__title">WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</span><span class="pl__date">17/02/09</span></a>
    
      <a class="项目维护 pl__all" href="/2017/01/22/UISearchBar-%E9%97%AA%E7%8E%B0%E8%83%8C%E6%99%AF%E8%89%B2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><span class="pl__circle"></span><span class="pl__title">UISearchBar 闪现背景色解决方案</span><span class="pl__date">17/01/22</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/01/19/iOS%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%E5%AF%B9%E8%AF%9D%E6%A1%86-RunLoop%E7%9A%84%E4%BD%BF%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">iOS同步调用对话框 RunLoop的使用</span><span class="pl__date">17/01/19</span></a>
    
      <a class="函数式Swift pl__all" href="/2017/01/10/iOS-Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-Core-Image-%E5%B0%81%E8%A3%85.html"><span class="pl__circle"></span><span class="pl__title">iOS-Swift函数式编程 Core Image 封装</span><span class="pl__date">17/01/10</span></a>
    
      <a class="开发笔记 pl__all" href="/2017/01/07/iOS-%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2(Objective-C)-NSTimeZone.html"><span class="pl__circle"></span><span class="pl__title">iOS-时区转换(Objective-C) NSTimeZone</span><span class="pl__date">17/01/07</span></a>
    
      <a class="函数式Swift pl__all" href="/2016/12/28/RxSwift-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">RxSwift 成长之路---基本概念和语法</span><span class="pl__date">16/12/28</span></a>
    
      <a class="开发笔记 pl__all" href="/2016/12/24/iOS-UILabel%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%AD%97%E5%A2%9E%E9%95%BF-%E5%87%8F%E5%B0%8F%E5%8A%A8%E7%94%BB.html"><span class="pl__circle"></span><span class="pl__title">iOS-UILabel扩展实现数字增长/减小动画</span><span class="pl__date">16/12/24</span></a>
    
      <a class="开发笔记 pl__all" href="/2016/12/23/iOS-%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6(%E5%8F%AF%E5%8D%95%E7%8B%AC%E9%80%89%E5%B9%B4-%E5%B9%B4%E6%9C%88-%E5%B9%B4%E6%9C%88%E6%97%A5).html"><span class="pl__circle"></span><span class="pl__title">iOS-日期选择控件(可单独选年/年月/年月日)</span><span class="pl__date">16/12/23</span></a>
    
    </nav>
  </div> <!-- end #posts-list -->
</aside> <!-- end #sidebar -->
    <div id="post">
      <div id="pjax">
        <article id="post__content">
    <h1 id="post__title" data-identifier="20161228">RxSwift 成长之路---基本概念和语法</h1>
    <blockquote>
  <p>更新时间: 2017-02-28
<a href="http://www.jianshu.com/p/2e0dfba02ae5">RxSwift + Moya + ObjectMapper + MVVM 的网络请求</a></p>
</blockquote>

<h1 id="说明">说明</h1>
<p>刚开始接触<code class="highlighter-rouge">RxSwift</code>, 很多概念理不清; 试着阅读官方的<code class="highlighter-rouge">playground</code>, 无奈英语水平有限, 看着英文文档,更加迷糊. 几经周折,找到这篇很好的教程, 作者整理的非常清晰, 感谢作者的分享精神.
请各位看官移步原文<a href="http://www.codertian.com/2016/11/27/RxSwift-ru-keng-ji-read-document/">田腾飞的博客 【iOS开发】RxSwift入坑解读-你所需要知道的各种概念</a></p>

<p>此处整理的不够清晰, 仅仅是为了自己对这些概念的进一步的记忆.所以为了不耽误大家的时间, 请大家点击这里,阅读原文作者的博客<a href="http://www.codertian.com/">沸沸腾（狒狒）</a></p>

<h1 id="文件目录预览-基本概念划分">文件目录预览, 基本概念划分</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/3538284-56ec8dfc17415f0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录" /></p>

<p><img src="http://upload-images.jianshu.io/upload_images/3538284-411971e968154f7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可依次取消注释,在控制台查看运行结果" /></p>

<h1 id="内容拆分">内容拆分</h1>
<h2 id="基本概念">基本概念</h2>
<blockquote>
  <ol>
    <li><code class="highlighter-rouge">Observable</code> 和 <code class="highlighter-rouge">Observer</code>
<code class="highlighter-rouge">Observable</code> 是可被观察的,理解为事件源.
<code class="highlighter-rouge">Observer</code> 是我们的观察者, 收到事件后, 事件的处理者
观察者需要订阅(<code class="highlighter-rouge">subscribe</code>) 被观察者,才能收到<code class="highlighter-rouge">Observable</code>的事件通知消息</li>
    <li>创建和订阅被观察者
创建被观察者其实就是创建一个<code class="highlighter-rouge">Observable</code>的<code class="highlighter-rouge">sequence</code>,就是创建一个流, 然后就可以被订阅<code class="highlighter-rouge">subscribe</code>, 这样被观察者发出事件, 我们就能做相应的处理</li>
    <li>DisposeBag
<code class="highlighter-rouge">DisposeBag</code> 其实相当于<code class="highlighter-rouge">iOS</code>中<code class="highlighter-rouge">ARC</code>, 在适当的时候销毁观察者, 理解为内存管理者</li>
    <li>subscribe
<code class="highlighter-rouge">subscribe</code>是订阅<code class="highlighter-rouge">sequence</code>发出的事件, 比如<code class="highlighter-rouge">next</code>事件, <code class="highlighter-rouge">error</code>事件等. 而<code class="highlighter-rouge">subscribe(onNext:)</code>是监听<code class="highlighter-rouge">sequence</code>发出的<code class="highlighter-rouge">next</code>事件中的<code class="highlighter-rouge">element</code>进行处理, 他会忽略<code class="highlighter-rouge">error</code>和<code class="highlighter-rouge">complete</code>事件. 相对应的还有<code class="highlighter-rouge">subscribe(onError:)</code> 和 <code class="highlighter-rouge">subscribe(onCompleted:)</code></li>
  </ol>
</blockquote>

<h3 id="never-是创建一个sequence-但是不发出任何事件信号"><code class="highlighter-rouge">never</code> 是创建一个<code class="highlighter-rouge">sequence</code>, 但是不发出任何事件信号</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable&lt;String&gt;.never().subscribe { (_) in
            print("不会打印这句话, 因为不会被执行")
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="empty-是创建一个空的sequence-只能发出一个complete事件"><code class="highlighter-rouge">empty</code> 是创建一个空的<code class="highlighter-rouge">sequence</code>, 只能发出一个<code class="highlighter-rouge">complete</code>事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable&lt;Int&gt;.empty().subscribe { event in print(event) }.addDisposableTo(disposeBag)
</code></pre>
</div>
<h3 id="just-是创建一个sequence能发出特定的事件-能正常结束"><code class="highlighter-rouge">just</code> 是创建一个<code class="highlighter-rouge">sequence</code>能发出特定的事件, 能正常结束</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable&lt;String&gt;.just("💗").subscribe { (string) in
            print(string)
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="of-是创建一个sequence-能发出很多事件信号-subscribe只监听事件"><code class="highlighter-rouge">of</code> 是创建一个<code class="highlighter-rouge">sequence</code> 能发出很多事件信号, subscribe只监听事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("1--", "2--", "3--", "4--").subscribe { (str) in
            print(str)
        }.addDisposableTo(DisposeBag())
        
        Observable.of("1--", "2--", "3--", "4--").subscribe(onNext: { (str) in
            print(str)
        }, onError: nil, onCompleted: nil, onDisposed: nil).addDisposableTo(DisposeBag())     
</code></pre>
</div>
<h3 id="from-是从集合中创建sequence-例如-字典-数组-set"><code class="highlighter-rouge">from</code> 是从集合中创建<code class="highlighter-rouge">sequence</code>, 例如: 字典, 数组, <code class="highlighter-rouge">set</code></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.from(["😀", "😬", "😂", "😅"]).subscribe(onNext: { print($0)
        }).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="create-我们可以自定义可观察的sequence"><code class="highlighter-rouge">create</code> 我们可以自定义可观察的<code class="highlighter-rouge">sequence</code></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let myJust: (String) -&gt; Observable&lt;String&gt; = { (element: String) -&gt; Observable&lt;String&gt; in
            return Observable.create({ (observer) -&gt; Disposable in
                observer.on(.next(element))
                observer.on(.completed)
                return Disposables.create()
            })
        }
        myJust("自定义可观察的sequence").subscribe(onNext: { (str) in
            print(str)
        }).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="range-就是创建一个sequence-他可以发出这个范围从开始到结束的所有事件"><code class="highlighter-rouge">range</code> 就是创建一个<code class="highlighter-rouge">sequence</code>, 他可以发出这个范围从开始到结束的所有事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.range(start: 1, count: 10).subscribe { print($0)
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="repeatelement-创建一个sequence-发出特定事件n次"><code class="highlighter-rouge">repeatElement</code> 创建一个<code class="highlighter-rouge">sequence</code>, 发出特定事件n次</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.repeatElement("⚾️").take(3).subscribe { print($0)
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="generate-是创建一个可观察的sequence-当初始化的条件为true时-他就会发出所对应的事件"><code class="highlighter-rouge">generate</code> 是创建一个可观察的<code class="highlighter-rouge">sequence</code>, 当初始化的条件为<code class="highlighter-rouge">true</code>时, 他就会发出所对应的事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.generate(initialState: 0, condition: { (element) -&gt; Bool in
            element &lt; 5
        }) { (element) -&gt; Int in
            element + 1
        }.subscribe { (element) in
            print(element)
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="deferred-延期-会为每一个订阅者observer-创建一个新的可观察序列"><code class="highlighter-rouge">deferred</code> (延期) 会为每一个订阅者<code class="highlighter-rouge">observer</code>, 创建一个新的可观察序列</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>var count = 1
        let deferredSequence = Observable&lt;String&gt;.deferred { () -&gt; Observable&lt;String&gt; in
            print("Creating \(count)")
            count += 1
            return Observable.create({ (observer) -&gt; Disposable in
                observer.onNext("🏄🏽‍♀️")
                observer.onNext("🏄")
                observer.onNext("⛷")
                return Disposables.create()
            })
        }
        deferredSequence.subscribe { print($0)
        }.addDisposableTo(DisposeBag())
        deferredSequence.subscribe { print($0)
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="error-创建一个可观察序列-但不发出任何正常的事件-只发出error事件并结束"><code class="highlighter-rouge">error</code> 创建一个可观察序列, 但不发出任何正常的事件, 只发出<code class="highlighter-rouge">error</code>事件并结束</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>
</code></pre>
</div>
<h3 id="doono-doonnext-方法就是在subscribeonnext前调用dooncompleted就是在subscribeoncompleted前面调用的"><code class="highlighter-rouge">doOno doOnNext( :)</code>方法就是在<code class="highlighter-rouge">subscribe(onNext:)</code>前调用，<code class="highlighter-rouge">doOnCompleted(:)</code>就是在<code class="highlighter-rouge">subscribe(onCompleted:)</code>前面调用的。</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🚗", "🚕", "🚙", "🚌").do(onNext: { (str) in
            print("doOn--\(str)")
        }, onError: nil, onCompleted: nil, onSubscribe: nil, onDispose: nil).subscribe { (str) in
            print(str)
        }.addDisposableTo(DisposeBag())
</code></pre>
</div>

<h2 id="subject的使用">Subject的使用</h2>
<blockquote>
  <p><code class="highlighter-rouge">Subject</code>是 <code class="highlighter-rouge">Observable</code> 和 <code class="highlighter-rouge">observer</code> 之间的桥梁, 一个<code class="highlighter-rouge">Subject</code> 既是<code class="highlighter-rouge">Observable</code> 也是 <code class="highlighter-rouge">observer</code>, 他既可以发出事件,又可以监听事件
<code class="highlighter-rouge">PublishSubject</code>, <code class="highlighter-rouge">ReplaySubject</code>和<code class="highlighter-rouge">BehaviorSubject</code>是不会自动发出<code class="highlighter-rouge">completed</code>事件的。</p>
</blockquote>

<h3 id="publishsubject--当你订阅publishsubject的时候-你只能接收到订阅他之后发生的事件-subjectonnext发出onnext事件对应的还有onerror和oncompleted事件"><code class="highlighter-rouge">publishSubject</code>  当你订阅<code class="highlighter-rouge">publishSubject</code>的时候, 你只能接收到订阅他之后发生的事件, <code class="highlighter-rouge">subject.onNext()</code>发出<code class="highlighter-rouge">onNext</code>事件，对应的还有<code class="highlighter-rouge">onError()</code>和<code class="highlighter-rouge">onCompleted()</code>事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let publishSubject = PublishSubject&lt;String&gt;()
        let disposeBag = DisposeBag()
        publishSubject.subscribe({ print("1---", $0)
        }).addDisposableTo(disposeBag)
        publishSubject.onNext("🐶")
        publishSubject.onNext("🐱")
        
        publishSubject.subscribe({ print("2---", $0)
        }).addDisposableTo(disposeBag)
        publishSubject.onNext("🅰️")
        publishSubject.onNext("🅱️")
</code></pre>
</div>
<h3 id="replaysubject-当你订阅replaysubject的时候-你可以接收到订阅他之后的事件-单页可以接收订阅他之前发出的事件-接收几个事件取决于buffersize的大小"><code class="highlighter-rouge">ReplaySubject</code> 当你订阅<code class="highlighter-rouge">ReplaySubject</code>的时候, 你可以接收到订阅他之后的事件, 单页可以接收订阅他之前发出的事件, 接收几个事件取决于<code class="highlighter-rouge">bufferSize</code>的大小</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let replaySubject = ReplaySubject&lt;Any&gt;.create(bufferSize: 3)
        let replayDisposeBag = DisposeBag()
        
        replaySubject.subscribe({ print("replaySubject--1--", $0)}).addDisposableTo(replayDisposeBag)
        replaySubject.onNext("A")
        replaySubject.onNext("B")
        replaySubject.onNext("C")
        replaySubject.onNext("D")
        
        replaySubject.subscribe({ print("replaySubject--2--", $0)}).addDisposableTo(replayDisposeBag)
        replaySubject.onNext("一")
        replaySubject.onNext("二")
</code></pre>
</div>
<h3 id="behaviorsubject-当你订阅了behasubject-你会接收到订阅之前的最后一个事件"><code class="highlighter-rouge">BehaviorSubject </code>当你订阅了<code class="highlighter-rouge">BehaSubject</code>, 你会接收到订阅之前的最后一个事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let behaviorSubject = BehaviorSubject(value: "🍎")
        let behaviorDisposeBag = DisposeBag()
        print("\n\n")
        behaviorSubject.subscribe({ print("BehaviorSubject--1--", $0) }).addDisposableTo(behaviorDisposeBag)
        behaviorSubject.onNext("🌝")
        behaviorSubject.onNext("🌛")
        behaviorSubject.onNext("🌟")
        behaviorSubject.subscribe({ print("BehaviorSubject--2--", $0)} ).addDisposableTo(behaviorDisposeBag)
        behaviorSubject.onNext("🌎")
        behaviorSubject.onNext("🌕")
</code></pre>
</div>

<blockquote>
  <p>注: <code class="highlighter-rouge">PublishSubject</code>, <code class="highlighter-rouge">ReplaySubject</code>和<code class="highlighter-rouge">BehaviorSubject</code>是不会自动发出<code class="highlighter-rouge">completed</code>事件的。</p>
</blockquote>

<h3 id="variable-是behaviorsubject的一个包装箱-就像是一个箱子一样-使用的时候需要调用asobservable拆箱-里面的value是一个behaviorsubject-他不会发出error事件-但是会自动发出complete事件"><code class="highlighter-rouge">Variable</code> 是<code class="highlighter-rouge">behaviorSubject</code>的一个包装箱, 就像是一个箱子一样, 使用的时候需要调用<code class="highlighter-rouge">asObservable</code>拆箱, 里面的<code class="highlighter-rouge">value</code>是一个<code class="highlighter-rouge">BehaviorSubject</code>, 他不会发出<code class="highlighter-rouge">error</code>事件, 但是会自动发出<code class="highlighter-rouge">complete</code>事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let variable = Variable("🌖")
        let variableDisposeBag = DisposeBag()
        variable.asObservable().subscribe({ print("variableDisposeBag--1--", $0)} ).addDisposableTo(variableDisposeBag)
        variable.value = "☀️"
        variable.value = "🌤"
        
        variable.asObservable().subscribe({ print("variableDisposeBag--2--", $0)}).addDisposableTo(variableDisposeBag)
        variable.value = "🔴"
        variable.value = "🔵"
</code></pre>
</div>

<h2 id="联合操作">联合操作</h2>

<blockquote>
  <p>联合操作就是把多个<code class="highlighter-rouge">Observable</code>(被观察者) 合并成单个<code class="highlighter-rouge">observable</code>流</p>
</blockquote>

<h3 id="startwith-在发出事件消息之前-先发出某个特定的事件消息-比如发出事件2-3-startwith1后会先发出1-然后发出2-3"><code class="highlighter-rouge">startWith</code> 在发出事件消息之前, 先发出某个特定的事件消息, 比如发出事件2, 3 ,startWith(1),后,会先发出1, 然后发出2, 3</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("2", "3").startWith("1").startWith( "-1", "0").subscribe({ print("startWith---",$0 )}).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="merge-把两个observable-流合并成一个observable流-根据时间轴发出对应的事件"><code class="highlighter-rouge">merge</code> 把两个<code class="highlighter-rouge">Observable</code> 流合并成一个<code class="highlighter-rouge">Observable</code>流, 根据时间轴发出对应的事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let mergeDisposeBag = DisposeBag()
        let mergeSubject1 = PublishSubject&lt;String&gt;()
        let mergeSubject2 = PublishSubject&lt;String&gt;()
        
        Observable.of(mergeSubject1, mergeSubject2).merge().subscribe(onNext: { print($0) }, onError: nil, onCompleted: nil, onDisposed: nil).addDisposableTo(mergeDisposeBag)
        mergeSubject1.onNext("🌕")
        mergeSubject1.onNext("🌖")
        mergeSubject2.onNext("🌗")
        mergeSubject1.onNext("🌘")
        mergeSubject2.onNext("🌑")
</code></pre>
</div>
<h3 id="zip-绑定小于等于8-个的observable流-结合在一起办理-注-zip-是一个事件对应一个事件-不满足配对的将会被抛弃"><code class="highlighter-rouge">zip</code> 绑定小于等于8 个的<code class="highlighter-rouge">Observable</code>流, 结合在一起办理, 注: zip 是一个事件对应一个事件, 不满足配对的将会被抛弃</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let stringSubject = PublishSubject&lt;String&gt;()
        let intSubject = PublishSubject&lt;Int&gt;()
        let zipDisposeBag = DisposeBag()
        
        Observable.zip(stringSubject, intSubject) { (stringElement, intElement) -&gt; String in
            return "\(stringElement) \(intElement)"
            }.subscribe(onNext: { print($0)}).addDisposableTo(zipDisposeBag)
        stringSubject.onNext("A")
        stringSubject.onNext("B")
        intSubject.onNext(1)
        intSubject.onNext(2)
        intSubject.onNext(3)
        stringSubject.onNext("C")
        intSubject.onNext(4)
</code></pre>
</div>

<h3 id="combinelatest-绑定最多不超过8个的obaservable-结合在一起处理-和zip-不同的是-combinelast是一个流的事件对应另一流的最后一个事件-两个流的事件都是最近的事件"><code class="highlighter-rouge">combineLatest</code> 绑定最多不超过8个的<code class="highlighter-rouge">Obaservable</code>, 结合在一起处理. 和<code class="highlighter-rouge">zip</code> 不同的是, <code class="highlighter-rouge">combineLast</code>是一个流的事件对应另一流的’最后’一个事件, 两个流的事件都是’最近’的事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let stringSubject2 = PublishSubject&lt;String&gt;()
        let intSubject2 = PublishSubject&lt;Int&gt;()
        let zipDisposeBag2 = DisposeBag()
        print("\n")
        Observable.combineLatest(stringSubject2, intSubject2) { (stringElement, intElement) -&gt; String in
            return "\(stringElement) \(intElement)"
            }.subscribe(onNext: { print($0)}).addDisposableTo(zipDisposeBag2)
        stringSubject2.onNext("A")
        stringSubject2.onNext("B")
        intSubject2.onNext(1)
        intSubject2.onNext(2)
        intSubject2.onNext(3)
        stringSubject2.onNext("C")
        intSubject2.onNext(4)
</code></pre>
</div>
<h3 id="switchlatest-可以对事件流进行转换-本来监听的subject1--我们可以通过改变variable里面的value-更换事件源-变成监听subject2"><code class="highlighter-rouge">switchLatest</code> 可以对事件流进行转换, 本来监听的<code class="highlighter-rouge">subject1</code> , 我们可以通过改变<code class="highlighter-rouge">variable</code>里面的<code class="highlighter-rouge">value</code>, 更换事件源, 变成监听<code class="highlighter-rouge">subject2</code></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let switchDisposeBag = DisposeBag()
        let subject1 = BehaviorSubject(value: "😍")
        let subject2 = BehaviorSubject(value: "😘")
        let variable = Variable(subject1)
        variable.asObservable().switchLatest().subscribe({ print($0)}).addDisposableTo(switchDisposeBag)
        subject1.onNext("🍏")
        subject1.onNext("🍎")
        subject2.onNext("🍝")
        variable.value = subject2
        subject1.onNext("🍉")
        subject2.onNext("🍲")
</code></pre>
</div>

<h2 id="变换操作">变换操作</h2>

<blockquote>
  <p>变换操作</p>
</blockquote>

<h3 id="map-通过传入一个函数闭包把原来的sequence-转换为一个新的sequence"><code class="highlighter-rouge">map</code> 通过传入一个函数闭包把原来的<code class="highlighter-rouge">sequence</code> 转换为一个新的<code class="highlighter-rouge">sequence</code></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of(1, 2, 3).map { $0 * $0
            }.subscribe({ print($0)}).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="flatmap-将一个sequence-转换为另一个sequence-当你接收一个sequence事件-你还想接收其他sequence发出的事件的话可以使用flatmap-他会将每一个sequence事件进行处理后-然后再以一个新的sequence形式发出事件"><code class="highlighter-rouge">flatMap</code> 将一个<code class="highlighter-rouge">sequence</code> 转换为另一个<code class="highlighter-rouge">sequence</code>, 当你接收一个<code class="highlighter-rouge">sequence</code>事件, 你还想接收其他<code class="highlighter-rouge">sequence</code>发出的事件的话,可以使用<code class="highlighter-rouge">flatMap</code>, 他会将每一个<code class="highlighter-rouge">sequence</code>事件进行处理后, 然后再以一个新的<code class="highlighter-rouge">sequence</code>形式发出事件.</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let flatMapDisposeBag = DisposeBag()
        struct Player {
            var score: Variable&lt;Int&gt;
        }
        let 😈 = Player(score: Variable(80))
        let 👻 = Player(score: Variable(90))
        let 💀 = Player(score: Variable(550))
        
        let variablePlayer = Variable(😈)
        variablePlayer.asObservable().flatMapLatest { $0.score.asObservable()
            }.subscribe({ print($0)}).addDisposableTo(flatMapDisposeBag)
        😈.score.value = 85
        variablePlayer.value = 👻
        😈.score.value = 95
        😈.score.value = 222
        
        variablePlayer.value = 💀
        👻.score.value = 100
        💀.score.value = 666
</code></pre>
</div>

<blockquote>
  <p>flatMapLatest 只会接收最新的value事件</p>
</blockquote>

<h3 id="scan-就是一个初始化的数-然后不断的拿前一个结果和最新的值-进行处理操作"><code class="highlighter-rouge">scan</code> 就是一个初始化的数, 然后不断的拿前一个结果和最新的值, 进行处理操作</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.range(start: 1, count: 100).scan(0) { (a, b) -&gt; Int in
            return a + b
            }.subscribe({ print($0)}).addDisposableTo(DisposeBag())
        Observable.of(10, 100, 1000).scan(0) { $0 + $1
            }.subscribe({ print($0)}).addDisposableTo(DisposeBag())
</code></pre>
</div>

<h2 id="过滤和约束">过滤和约束</h2>

<blockquote>
  <p>过滤和约束</p>
</blockquote>

<h3 id="filter-过滤掉某些不符合要求的事件"><code class="highlighter-rouge">filter</code> 过滤掉某些不符合要求的事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("😀", "😙", "😀", "😀", "😜", "😍", "😇", "😗", "😘", "🙃", "😉").filter { (str) -&gt; Bool in
            return str == "😀"
            }.subscribe({ print($0)}).addDisposableTo(DisposeBag())
        Observable.range(start: 0, count: 100).filter { (num) -&gt; Bool in
            return num % 2 == 0
            }.subscribe({ print($0)}).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="distinctuntilchanged-当下一个事件与前一个事件不是同一个事件才进行处理操作"><code class="highlighter-rouge">distinctUntilChanged</code> 当下一个事件与前一个事件不是同一个事件才进行处理操作</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("⚽️", "🏈", "🏀", "⚾️", "⚾️", "⚾️", "🏀", "⚽️", "🏀", "⚽️", "⚽️", "🎾", "🏐", "⚽️", "🏐", "🏐").distinctUntilChanged().subscribe( { print($0)} ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="elementat-只处理在指定位置的事件">elementAt 只处理在指定位置的事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🎤", "🎼", "🎹", "🎧").single().subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>

<blockquote>
  <p>error(Sequence contains more than one element.)</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🎹", "🎹", "🎧").single( {$0 == "🎧"} ).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>

<blockquote>
  <p>completed</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🎹", "🎹", "🎧").single( {$0 == "🎹"} ).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>

<blockquote>
  <p>error(Sequence contains more than one element.)</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🎹", "🎹", "🎧").single( {$0 == "🎤"} ).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>

<blockquote>
  <p>error(Sequence doesn’t contain any elements.)</p>
</blockquote>

<h3 id="take-只处理前几个事件信号"><code class="highlighter-rouge">take</code> 只处理前几个事件信号</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("☮️", "☪️", "🔯", "☯️", "♉️", "♒️").take(3).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="takelast-只处理后几个事件信号"><code class="highlighter-rouge">takeLast</code> 只处理后几个事件信号</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("☮️", "☪️", "🔯", "☯️", "♉️", "♒️").takeLast(3).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="takewhile-当条件满足时处理"><code class="highlighter-rouge">takeWhile</code> 当条件满足时处理</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.range(start: 1, count: 5).takeWhile( { $0 &lt;= 3} ).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="takeuntil-接收事件消息-直到另一个sequence-发出事件消息的时候"><code class="highlighter-rouge">takeUntil</code> 接收事件消息, 直到另一个sequence 发出事件消息的时候</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let sourceSequence = PublishSubject&lt;String&gt;()
        let stopSequence = PublishSubject&lt;String&gt;()
        let takeUntilDisposeBag = DisposeBag()
        sourceSequence.takeUntil(stopSequence).subscribe( { print($0) } ).addDisposableTo(takeUntilDisposeBag)
        sourceSequence.onNext("♻️")
        sourceSequence.onNext("🈯️")
        stopSequence.onNext("⛔️")
        sourceSequence.onNext("💹")
</code></pre>
</div>
<h3 id="skip-取消前几个事件"><code class="highlighter-rouge">skip</code> 取消前几个事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🈶", "🈷️", "🈺", "🈸", "🈚️").skip(2).subscribe( { print($0)} ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="skipwhile-满足事件消息的都取消-当遇到不满足条件的事件消息后后面的就不考虑了"><code class="highlighter-rouge">skipWhile</code> 满足事件消息的都取消, 当遇到不满足条件的事件消息后,后面的就不考虑了</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of("🈶", "🈷️", "🈺", "🈸", "🈚️").skipWhile( { $0 == "🈶"} ).subscribe( { print($0)} ).addDisposableTo(DisposeBag())
        Observable.range(start: 0, count: 5).skipWhile( { $0 &lt; 3} ).subscribe( { print($0)} ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="skipwhilewithindex-满足条件的都被取消-可以根据元素和下表分别决定-传入的闭包和skipwhile有点区别而已-当遇到不满足条件的事件消息后后面的就不考虑了"><code class="highlighter-rouge">skipWhileWithIndex</code> 满足条件的都被取消, 可以根据元素和下表分别决定, 传入的闭包和<code class="highlighter-rouge">skipWhile</code>有点区别而已, 当遇到不满足条件的事件消息后,后面的就不考虑了</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let skipWithIndexDisposeBag = DisposeBag()
        Observable.of("1🈶", "2😀", "1🈺", "🈸", "😅").skipWhileWithIndex { (element, index) -&gt; Bool in
            return index != 3
            }.subscribe( { print("----", $0)} ).addDisposableTo(skipWithIndexDisposeBag)
</code></pre>
</div>

<blockquote>
  <p>注: 当遇到不满足条件的事件消息后,后面的就不考虑了</p>
</blockquote>

<h3 id="skipuntil-知道某个sequence发出了事件消息-才开始接收当前sequence发出的事件消息"><code class="highlighter-rouge">skipUntil</code> 知道某个<code class="highlighter-rouge">sequence</code>发出了事件消息, 才开始接收当前<code class="highlighter-rouge">sequence</code>发出的事件消息</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let skipUntilDisposeBag = DisposeBag()
        let skipUntilStartSubject = PublishSubject&lt;String&gt;()
        let skipUntilStopSubject = PublishSubject&lt;Int&gt;()
        skipUntilStartSubject.skipUntil(skipUntilStopSubject).subscribe( { print($0) } ).addDisposableTo(skipUntilDisposeBag)
        skipUntilStartSubject.onNext("🐠")
        skipUntilStartSubject.onNext("🐟")
        
        skipUntilStopSubject.onNext(0)// skipUntilStopSubject 接收消息后, skipUntilStartSubject才会开始接收消息
        
        skipUntilStartSubject.onNext("🐡")
        skipUntilStartSubject.onNext("🐬")
</code></pre>
</div>

<blockquote>
  <p>注:   <code class="highlighter-rouge">skipUntilStopSubject</code> 接收消息后, <code class="highlighter-rouge">skipUntilStartSubject</code>才会开始接收消息</p>
</blockquote>

<h2 id="数学操作">数学操作</h2>

<blockquote>
  <p>数学操作</p>
</blockquote>

<h3 id="toarray-将sequence转换成一个array-并转换成单一事件信号-然后结束"><code class="highlighter-rouge">toArray</code> 将<code class="highlighter-rouge">sequence</code>转换成一个<code class="highlighter-rouge">Array</code>, 并转换成单一事件信号, 然后结束</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.range(start: 1, count: 10).toArray().subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="reduce-用一个初始值-对事件数据进行累计操作-reduce-接收一个初始值和一个操作符"><code class="highlighter-rouge">reduce</code> 用一个初始值, 对事件数据进行累计操作. <code class="highlighter-rouge">reduce</code> 接收一个初始值,和一个操作符</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>Observable.of(10, 100, 1000).reduce(1, accumulator: +).subscribe( { print($0) } ).addDisposableTo(DisposeBag())
</code></pre>
</div>
<h3 id="concat-合并-把多个sequence-合并为-一个-sequence-并且当前面一个sequence发出了complete事件-才会开始下一个sequence事件"><code class="highlighter-rouge">concat</code> (合并) 把多个<code class="highlighter-rouge">sequence</code> 合并为 一个 <code class="highlighter-rouge">sequence</code>, 并且当前面一个<code class="highlighter-rouge">sequence</code>发出了<code class="highlighter-rouge">complete</code>事件, 才会开始下一个<code class="highlighter-rouge">sequence</code>事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let concatDisposeBag = DisposeBag()
        let concatBehaviorSubject1 = BehaviorSubject(value: "☀️")
        let concatBehaviorSubject2 = BehaviorSubject(value: "🍎")
        
        let concatVariable = Variable(concatBehaviorSubject1)
        concatVariable.asObservable().concat().subscribe( { print($0) } ).addDisposableTo(concatDisposeBag)
        
        concatBehaviorSubject1.onNext("🌧")
        concatBehaviorSubject1.onNext("❄️")
        concatVariable.value = concatBehaviorSubject2
        concatBehaviorSubject2.onNext("🍓")
        concatBehaviorSubject1.onCompleted()
        concatBehaviorSubject2.onNext("🍒")
        concatBehaviorSubject2.onNext("🍉")
        concatBehaviorSubject1.onNext("⛅️")
</code></pre>
</div>

<blockquote>
  <p>next(☀️)
         next(🌧)
         next(❄️)
         next(🍓)
         next(🍒)
         next(🍉)</p>
</blockquote>

<h2 id="连接性操作">连接性操作</h2>

<blockquote>
  <p>Connectable Observable 订阅时不开始发射事件消息, 而是仅当调用他们的connec() 方法时.
这样就可以等待我们所有想要的订阅者都订阅了以后再开始发事件消息, 这样能保证我们所有的订阅者都能够接收到事件消息. 简单说就是等大家都准备完成后, 才开始发消息</p>
</blockquote>

<h3 id="例-每隔一秒-发送一个事件">例: 每隔一秒 发送一个事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let interval = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)
       _ = interval.subscribe(onNext: { print("Subscription: 1, Event: \($0)") })
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 5) {
           _ = interval.subscribe(onNext: { print("Subscription: 2, Event: \($0)") })
       }
</code></pre>
</div>
<h3 id="publish-将一个正常的sequence-转换为-connectable-sequence-可以指定时间发送事件"><code class="highlighter-rouge">publish</code> 将一个正常的<code class="highlighter-rouge">sequence</code> 转换为 <code class="highlighter-rouge">connectable sequence</code>, 可以指定时间发送事件</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance).publish()
       _ = intSequence.subscribe(onNext: { print("Subscription: 1, Event: \($0)") })
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) {
           _ = intSequence.connect()
       }
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 4) {
           _ = intSequence.subscribe(onNext: { print("Subscription: 2, Event: \($0)") })
       }
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 6) {
           _ = intSequence.subscribe(onNext: { print("Subscription: 3, Event: \($0)") })
       }
</code></pre>
</div>
<h3 id="replay-讲一个正常的sequence-转换成一个connectable-sequence-然后和replaysubject的buffersize相似-能接收到订阅之前的事件消息"><code class="highlighter-rouge">replay</code> 讲一个正常的<code class="highlighter-rouge">sequence</code> 转换成一个<code class="highlighter-rouge">connectable sequence</code>, 然后和<code class="highlighter-rouge">replaySubject</code>的`bufferSize相似, 能接收到订阅之前的事件消息</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let replaySequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance).replay(1) // 能接收到订阅之前的n条信息
       _ = replaySequence.subscribe( { print("第1个订阅者--Event", $0)} )
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) {
           _ = replaySequence.connect()
       }
       
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 4) {
           _ = replaySequence.subscribe( { print("第2个订阅者--Event", $0)} )
       }
       
       DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 6) {
           _ = replaySequence.subscribe( { print("第3个订阅者--Event", $0)} )
       }
</code></pre>
</div>
<h3 id="multicast-将一个正常的sequence-转换为-connectable-sequence--并且通过特定的subject发送出去-例-publishsubject-replaysubject-behaviorsubject-variable"><code class="highlighter-rouge">multicast</code> 将一个正常的<code class="highlighter-rouge">sequence</code> 转换为 <code class="highlighter-rouge">connectable sequence</code> , 并且通过特定的<code class="highlighter-rouge">subject</code>发送出去, 例: <code class="highlighter-rouge">publishSubject</code>, <code class="highlighter-rouge">replaySubject</code>, <code class="highlighter-rouge">behaviorSubject</code>, <code class="highlighter-rouge">Variable</code></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let subject = PublishSubject&lt;Int&gt;()
        _ = subject.subscribe( { print("subject1--", $0) } )
        let multicastSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance).multicast(subject)
        _ = multicastSequence.subscribe( { print("subject2--", $0) } )
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) { 
            _ = multicastSequence.connect()
        }
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 4) {
            _ = multicastSequence.subscribe( { print("subject3--", $0) } )
        }
</code></pre>
</div>

<h2 id="错误处理">错误处理</h2>

<blockquote>
  <p>错误处理</p>
</blockquote>

<h3 id="catcherrorjustreturn-遇到error的时候就return一个值-然后结束"><code class="highlighter-rouge">catchErrorJustReturn</code> 遇到’error’的时候就’return’一个值, 然后结束</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let justReturnDisposeBag = DisposeBag()
        let justReturnSubject = PublishSubject&lt;String&gt;()
        justReturnSubject.catchErrorJustReturn("😱").subscribe( { print($0) } ).addDisposableTo(justReturnDisposeBag)
        justReturnSubject.onNext("☺️")
        justReturnSubject.onNext("😋")
        justReturnSubject.onNext("😍")
        justReturnSubject.onError(NSError(domain: "❎", code: 1000001, userInfo: nil) as Error)
</code></pre>
</div>
<h3 id="catcherror-捕获error进行处理-可以返回另一个sequence-进行订阅"><code class="highlighter-rouge">catchError</code> 捕获<code class="highlighter-rouge">error</code>进行处理, 可以返回另一个<code class="highlighter-rouge">sequence</code> 进行订阅</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let catchErrorDisposeBag = DisposeBag()
        let catchErrorSubject1 = PublishSubject&lt;String&gt;()
        let catchErrorSubject2 = PublishSubject&lt;String&gt;()
        catchErrorSubject1.catchError { (error) -&gt; Observable&lt;String&gt; in
            print("errro: ---\(error)")
            return catchErrorSubject2
            }.subscribe( { print($0) } ).addDisposableTo(catchErrorDisposeBag)
        catchErrorSubject1.onNext("😀")
        catchErrorSubject1.onNext("😬")
        catchErrorSubject2.onNext("😂") // 不会打印, 当subject1 遇到error后, subject2 才会被订阅
        
        catchErrorSubject1.onError(NSError(domain: "❎", code: 1000001, userInfo: nil) as Error)
        catchErrorSubject2.onNext("🤑") // 会打印, 因为已经被订阅了
</code></pre>
</div>
<h3 id="retry-重试-遇见error事件可以进行重试-比如网络请求失败-可以进行重新连接"><code class="highlighter-rouge">retry</code> (重试) 遇见<code class="highlighter-rouge">error</code>事件可以进行重试, 比如网络请求失败, 可以进行重新连接</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let retryDisposeBag = DisposeBag()
        var count = 1
        let myRetrySequence = Observable&lt;String&gt;.create { (observer) -&gt; Disposable in
            observer.onNext("----1")
            observer.onNext("----2")
            observer.onNext("----3")
            if count &lt;= 2 {
                let error = NSError(domain: "❎", code: 1000001, userInfo: nil) as Error
                observer.onError(error)
                print(error)
                count += 1
            }
            observer.onNext("----4")
            observer.onCompleted()
            
            return Disposables.create()
        }
myRetrySequence.retry(5).subscribe( { print($0) } ).addDisposableTo(retryDisposeBag)
</code></pre>
</div>
<blockquote>
  <p><code class="highlighter-rouge">retry()</code> 无限重复— 直到成功</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>myRetrySequenceretry().subscribe( { print($0) } ).addDisposableTo(retryDisposeBag)
</code></pre>
</div>

<h2 id="debug">debug</h2>

<blockquote>
  <p>debug</p>
</blockquote>

<h3 id="debug-打印所有的订阅-事件-和disposals"><code class="highlighter-rouge">debug</code> 打印所有的订阅, 事件, 和<code class="highlighter-rouge">disposals</code></h3>
<div class="highlighter-rouge"><pre class="highlight"><code>myRetrySequence.debug().retry(5).subscribe( { print($0) } ).addDisposableTo(retryDisposeBag)
</code></pre>
</div>
<h3 id="rxswiftresourcestotal-查看rxswift-所有资源的占用">RxSwift.Resources.total 查看RxSwift 所有资源的占用</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>print(RxSwift.Resources.total)
</code></pre>
</div>

<blockquote>
  <p>RxSwift.Resources.total 没能调用成功 😂</p>
</blockquote>

<h1 id="代码稍后会上传到github-需要查看结果的小伙伴可以下载运行">代码稍后会上传到github, 需要查看结果的小伙伴可以下载运行</h1>

<h1 id="写在最后-本人ios开发菜鸟一枚-不妥之处还望大神指教">写在最后 本人iOS开发菜鸟一枚, 不妥之处,还望大神指教~~~~~~~~~~~</h1>


    <div class="declare">
        <div>

        </div>
    </div>
</article>
<!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://localhost:4000/2016/12/28/RxSwift-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95.html&text=RxSwift 成长之路---基本概念和语法" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="https://github.com/YQqiang" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://localhost:4000/2016/12/28/RxSwift-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95.html&title=RxSwift 成长之路---基本概念和语法" target="_blank"></a>
    <!-- <div class="share-info">分享一下~</div> -->
</div>
<div id="qrcode" >
	<img src="http://localhost:4000/assets/images/qrcode.jpg" style="margin: 0 auto;display: block;" width="200" height="200" alt="">
</div>
<!-- end #post__share -->
<div id="disqus_thread" name="余强">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div>


            <!---->
    <!--<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>-->
    <!--&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a>-->
    <!--&nbsp;&nbsp;|&nbsp;&nbsp;Hosted on <a href="https://pages.github.com" target="_blank">Github</a></p>-->
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.pjax.js"></script>
<script src="/assets/js/nprogress.js"></script>
<script src="/assets/js/searchbox.js"></script>
<script src="/assets/js/script.js"></script>


    <script>
    //百度站点统计,排除localhost
    if(window.location.host.indexOf("localhost") ==-1 &&  window.location.host.indexOf("127.0.0.1") == -1){

        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?22d94317cfb9f9e0bb476228d9f79278";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }
</script>
   </body>
 </html>